AWSTemplateFormatVersion: "2010-09-09"
Description: Deploys BFF to FARGATE
Metadata:
  "AWS::CloudFormation::Interface":
    ParameterGroups:
      - Label:
          default: "Application Service Container"
        Parameters:
          - HealthCheckUrlPath
          - ContainerPort
          - ContainerCpu
          - ContainerTaskCpu
          - ContainerMemory
          - ImageVersion
      - Label:
          default: 'DNS Setup'
          Parameters:
            - HostedZoneName
            - AliasName
      - Label:
          default: "Stacks References"
        Parameters:
          - NetworkStackName
          - DeploymentStackName
      - Label:
          default: "Elastic Load Balancing"
        Parameters:
          - Path
          - Priority
      - Label:
          default: "Fargate Setup"
        Parameters:
          - DesiredCount

Parameters:
  HealthCheckUrlPath:
    Type: String
    Default: /health/
    Description: "What is the health check path for your service?"
  ContainerPort:
    Type: Number
    Default: 8080
    Description: What port number the application inside the docker container is binding to
  ContainerCpu:
    Type: Number
    Default: 256
    Description: How much CPU to give the container. 1024 is 1 CPU
  ContainerTaskCpu:
    Type: Number
    Default: 224
    Description: How much CPU to give the container. 1024 is 1 CPU
  ContainerMemory:
    Type: Number
    Default: 512
    Description: How much memory in megabytes to give the container
  CertificateArn:
    Type: String
    Description: The Certificate ARN

  HostedZoneName:
    Type: String
    Description: The Hostend Zone Name
  AliasName:
    Type: String
    Description: The Route53 Alias Name

  Path:
    Type: String
    Default: "*"
    Description: A path on the public load balancer that this service
      should be connected to. Use * to send all load balancer
      traffic to this service.
  Priority:
    Type: Number
    Default: 1
    Description: The priority for the routing rule added to the load balancer.
      This only applies if your have multiple services which have been
      assigned to different paths on the load balancer.
  DesiredCount:
    Type: Number
    Default: 2
    Description: How many copies of the service task to run
  NetworkStackName:
    Type: String
    Description: The Application Network Stack name
    Default: PetraRideNetwork-Dev
  DeploymentStackName:
    Type: String
    Description: The Deployment Stack name
  ImageVersion:
    Type: String
    Default: latest
    Description: The ECR Image version

Resources:
  CloudwatchLogsGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ["-", ["PetraRideLogGroup", !Ref "AWS::StackName"]]
      RetentionInDays: 14

  ECSTaskRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [ecs-tasks.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Path: /
      Policies:
        - PolicyName: AllowS3Access
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3:Put*
                  - s3:*
                  - logs:*
                Resource: '*'
              - Effect: Allow
                Action:
                  - s3:*Object*
                  - s3:ListMultipartUploadParts
                  - s3:AbortMultipartUpload
                  - logs:*
                Resource: '*'
        - PolicyName: AllowAPIGateway
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "apigateway:*"
                  - "execute-api:*"
                Resource: "*"
        - PolicyName: AllowDynamoDBAccess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:DeleteItem
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Scan
                Resource: "*"
        - PolicyName: ECSExec
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "ssmmessages:CreateControlChannel"
                  - "ssmmessages:CreateDataChannel"
                  - "ssmmessages:OpenControlChannel"
                  - "ssmmessages:OpenDataChannel"
                  - "ssm:GetParameters"
                Resource: "*"
        - PolicyName: AllowCognitoAccess
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: cognito-idp:*
                Resource: "*"
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family:
        Fn::ImportValue: !Sub "${DeploymentStackName}:ServiceName"

      Cpu: !Ref "ContainerCpu"
      Memory: !Ref "ContainerMemory"
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      ExecutionRoleArn: !ImportValue
        "Fn::Sub": "${NetworkStackName}:ECSTaskExecutionRole"
      TaskRoleArn: !Ref ECSTaskRole
      ContainerDefinitions:
        - Name:
            Fn::ImportValue: !Sub "${DeploymentStackName}:ServiceName"
          Cpu: !Ref "ContainerTaskCpu"
          Memory: !Ref "ContainerMemory"
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref "CloudwatchLogsGroup"
              awslogs-region: !Ref "AWS::Region"
              awslogs-stream-prefix: ecs-demo-app
          Image:
            Fn::Join:
              - ":"
              - - Fn::ImportValue: !Sub "${DeploymentStackName}:ImageUrl"
                - !Ref "ImageVersion"
          PortMappings:
            - ContainerPort: !Ref "ContainerPort"
          Environment:
            - Name: DEPLOYMENT_STAGE
              Value: !ImportValue
                "Fn::Sub": "${DeploymentStackName}:DeploymentStage"
            - Name: SERVICE_NAME
              Value: !ImportValue
                "Fn::Sub": "${DeploymentStackName}:ServiceName"
            - Name: AWS_REGION
              Value: "us-west-2"
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName:
        Fn::ImportValue: !Sub "${DeploymentStackName}:ServiceName"
      Cluster: !ImportValue
        "Fn::Sub": "${NetworkStackName}:ClusterName"
      LaunchType: FARGATE
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref "DesiredCount"
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !ImportValue
              "Fn::Sub": "${NetworkStackName}:FargateContainerSecurityGroup"
          Subnets:
            - !ImportValue
              "Fn::Sub": "${NetworkStackName}:PublicSubnetOne"
            - !ImportValue
              "Fn::Sub": "${NetworkStackName}:PublicSubnetTwo"
      TaskDefinition: !Ref "TaskDefinition"
      EnableExecuteCommand: true
      LoadBalancers:
        - ContainerName:
            Fn::ImportValue: !Sub "${DeploymentStackName}:ServiceName"
          ContainerPort: !Ref "ContainerPort"
          TargetGroupArn: !Ref "TargetGroup"
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 20
      HealthCheckPath: !Ref HealthCheckUrlPath
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 15
      HealthyThresholdCount: 2
      TargetType: ip
      Name:
        Fn::ImportValue: !Sub "${DeploymentStackName}:ServiceName"
      Port: !Ref "ContainerPort"
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !ImportValue
        "Fn::Sub": "${NetworkStackName}:VPCId"
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - TargetGroupArn: !Ref "TargetGroup"
          Type: "forward"
      Conditions:
        - Field: path-pattern
          Values: [!Ref "Path"]
      ListenerArn: !Ref PublicLoadBalancerListener
      Priority: !Ref "Priority"

  PublicLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      LoadBalancerAttributes:
        - Key: idle_timeout.timeout_seconds
          Value: "30"
      Subnets:
        - !ImportValue
          "Fn::Sub": "${NetworkStackName}:PublicSubnetOne"
        - !ImportValue
          "Fn::Sub": "${NetworkStackName}:PublicSubnetTwo"
      SecurityGroups:
        - !ImportValue
          "Fn::Sub": "${NetworkStackName}:PublicLoadBalancerSG"

  DummyTargetGroupPublic:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 20
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 15
      HealthyThresholdCount: 2
      Name: !Join ["-", [!Ref "AWS::StackName", "drop-1"]]
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId: !ImportValue
        "Fn::Sub": "${NetworkStackName}:VPCId"
  PublicLoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    DependsOn:
      - PublicLoadBalancer
    Properties:
      Certificates:
        - CertificateArn: !Ref 'CertificateArn'
      DefaultActions:
        - TargetGroupArn: !Ref "DummyTargetGroupPublic"
          Type: "forward"
      LoadBalancerArn: !Ref "PublicLoadBalancer"
      Port: 443
      Protocol: HTTPS
  HTTPlistener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      DefaultActions:
        - Type: "redirect"
          RedirectConfig:
            Protocol: "HTTPS"
            Port: 443
            Host: "#{host}"
            Path: "/#{path}"
            Query: "#{query}"
            StatusCode: "HTTP_301"
      LoadBalancerArn: !Ref "PublicLoadBalancer"
      Port: 80
      Protocol: "HTTP"
  DNSRoutingStack:
    Type: AWS::Route53::RecordSet
    Properties:
      AliasTarget:
        DNSName: !GetAtt 'PublicLoadBalancer.DNSName'
        EvaluateTargetHealth: true
        HostedZoneId: !GetAtt 'PublicLoadBalancer.CanonicalHostedZoneID'
      HostedZoneName: !Ref 'HostedZoneName'
      Comment: API Server for my backend
      Name: !Ref 'AliasName'
      Type: A
Outputs:
  Service:
    Value: !Ref Service
  LoadBalancerURL:
    Description: The url of the external load balancer
    Value: !Join ["", ["http://", !GetAtt "PublicLoadBalancer.DNSName"]]
    Export:
      Name: !Join [":", [!Ref "AWS::StackName", "LoadBalancerUrl"]]
  EndpointURL:
    Value: "{{resolve:ssm:/urls/admin/bff/service}}"
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'EndpointUrl' ] ]